@page "/transactions"
@using FinancesTracker.Client.Services
@using FinancesTracker.Shared.DTOs
@using FinancesTracker.Shared.Constants
@using Microsoft.AspNetCore.Components.Web
@using MudBlazor
@* @rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false)) *@
@inject cTransactionService TransactionService
@inject cCategoryService CategoryService
@inject IJSRuntime JSRuntime

<PageTitle>Transakcje</PageTitle>

<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h2>Transakcje finansowe</h2>
                <button class="btn btn-primary">
                    <i class="fas fa-plus"></i> Dodaj transakcję
                </button>
            </div>

            <!-- Filtry -->
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="card-title mb-0">Filtry</h5>
                </div>
                <div class="card-body">
                    <div class="row g-3">
                        <div class="col-md-3">
                            <label class="form-label">Rok</label>
                            <select class="form-select" @bind="mFilter.Year" >
                                <option value="">Wszystkie</option>
                                @for (int pYear = DateTime.Now.Year; pYear >= DateTime.Now.Year - 5; pYear--) {
                                    <option value="@pYear">@pYear</option>
                                }
                            </select>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Miesiąc</label>
                            <select class="form-select" @bind="mFilter.Month">
                                <option value="">Wszystkie</option>
                                @foreach (var pMonth in AppConstants.Months.Polish) {
                                    <option value="@pMonth.Key">@pMonth.Value</option>
                                }
                            </select>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Kategoria</label>
                            <select class="form-select" @bind="mFilter.CategoryId">
                                <option value="">Wszystkie</option>
                                @if (mCategories != null) {
                                    @foreach (var pCategory in mCategories) {
                                        <option value="@pCategory.Id">@pCategory.Name</option>
                                    }
                                }
                            </select>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Podkategoria</label>
                            <select class="form-select" @bind="mFilter.SubcategoryId">
                                <option value="">Wszystkie</option>
                                @if (mSubcategories != null) {
                                    @foreach (var pSubcategory in mSubcategories) {
                                        <option value="@pSubcategory.Id">@pSubcategory.Name</option>
                                    }
                                }
                            </select>
                        </div>
                    </div>
                    <div class="row g-3 mt-2">
                        <div class="col-md-6">
                            <label class="form-label">Szukaj</label>
                            <input type="text" class="form-control" @bind="mFilter.SearchTerm"  placeholder="Szukaj w opisie...">
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Kwota od</label>
                            <input type="number" class="form-control" @bind="mFilter.MinAmount" step="0.01">
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Kwota do</label>
                            <input type="number" class="form-control" @bind="mFilter.MaxAmount" step="0.01">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Lista transakcji -->
            @if (mIsLoading) {
                <div class="text-center p-4">
                    <MudProgressCircular Indeterminate="true" Color="Color.Primary" Size="Size.Large" />
                </div>
            } else if (mTransactions?.Items?.Any() == true) {
                <MudPaper Class="pa-4">
                    <MudTable Items="mTransactions.Items" Hover="true" Dense="true" Bordered="true" Striped="true">
                        <HeaderContent>
                            <MudTh>Data</MudTh>
                            <MudTh>Opis</MudTh>
                            <MudTh>Kwota</MudTh>
                            <MudTh>Kategoria</MudTh>
                            <MudTh>Podkategoria</MudTh>
                            <MudTh>Bank</MudTh>
                            <MudTh>Akcje</MudTh>
                        </HeaderContent>
                        <RowTemplate>
                            <MudTd DataLabel="Data">@context.Date.ToString("dd.MM.yyyy")</MudTd>
                            <MudTd DataLabel="Opis">@context.Description</MudTd>
                            <MudTd DataLabel="Kwota">
                                <span class="@(context.Amount >= 0 ? "text-success" : "text-danger")">
                                    @context.Amount.ToString("C", System.Globalization.CultureInfo.GetCultureInfo("pl-PL"))
                                </span>
                            </MudTd>
                            <MudTd DataLabel="Kategoria">@context.CategoryName</MudTd>
                            <MudTd DataLabel="Podkategoria">@context.SubcategoryName</MudTd>
                            <MudTd DataLabel="Bank">@context.BankName</MudTd>
                            <MudTd DataLabel="Akcje">
                                <MudButton Variant="Variant.Outlined" Color="Color.Primary" Size="Size.Small">
                                    <MudIcon Icon="@Icons.Material.Filled.Edit" />
                                </MudButton>
                                <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" OnClick="() => DeleteTransaction(context.Id)">
                                    <MudIcon Icon="@Icons.Material.Filled.Delete" />
                                </MudButton>
                            </MudTd>
                        </RowTemplate>
                    </MudTable>
                </MudPaper>
            } else {
                <MudPaper Class="pa-4 text-center">
                    <MudIcon Icon="@Icons.Material.Filled.Inbox" Size="Size.Large" Color="Color.Default" Class="mb-3" />
                    <h5 class="text-muted">Brak transakcji</h5>
                    <p class="text-muted">Nie znaleziono transakcji spełniających kryteria wyszukiwania.</p>
                </MudPaper>
            }
        </div>
    </div>
</div>

@code {
    //przechowuje listę transakcji
    private PagedResult<TransactionDto> mTransactions = new();

    //przechowuje listę kategorii
    private List<cCategory_DTO> mCategories = new();

    //przechowuje listę podkategorii
    private List<cSubcategory_DTO> mSubcategories = new();

    //przechowuje aktualne filtry
    private TransactionFilterDto mFilter = new();

    //przechowuje informację o ładowaniu danych
    private bool mIsLoading = true;

    //metoda wywoływana podczas inicjalizacji komponentu
    protected override async Task OnInitializedAsync() {
        //ładuje transakcje przy starcie komponentu
        await LoadTransactions();
    }

    //ładuje transakcje z serwisu na podstawie filtrów
    //brak parametrów
    private async Task LoadTransactions() {
        mIsLoading = true;

        Console.WriteLine("TEST");

        try {
            var pResp = await TransactionService.GetTransactionsAsync(mFilter);
            if (!pResp.Success) {
                Console.WriteLine($"Błąd podczas ładowania transakcji: {BuildErrorMessage(pResp)}");
                mTransactions = new PagedResult<TransactionDto>();
            } else {
                mTransactions = pResp.Data ?? new PagedResult<TransactionDto>();
            }
        } catch (Exception pEx) {
            Console.WriteLine($"Błąd podczas ładowania transakcji: {pEx.Message}");
            mTransactions = new PagedResult<TransactionDto>();
        } finally {
            mIsLoading = false;
        }

    }

    //usuwa transakcję o podanym identyfikatorze
    //xTransactionId - identyfikator transakcji do usunięcia
    private async Task DeleteTransaction(int xTransactionId) {
        //potwierdzenie usunięcia
        bool pConfirmDelete = await JSRuntime.InvokeAsync<bool>("confirm", "Czy na pewno chcesz usunąć tę transakcję?");
        if (!pConfirmDelete)
            return;

        try {
            var pResp = await TransactionService.DeleteTransactionAsync(xTransactionId);

            //jawne rzutowanie, aby odczytać właściwość Success (uniknięcie kolizji ze statyczną metodą Success)
            if (!((ApiResponse<object>)pResp).Success) {
                var pMsg = pResp.Message ?? (pResp.Errors is { Count: > 0 }
                    ? string.Join(", ", pResp.Errors)
                    : "Nie udało się usunąć transakcji.");

                Console.WriteLine($"Błąd podczas usuwania transakcji: {pMsg}");
                await JSRuntime.InvokeVoidAsync("alert", $"Wystąpił błąd podczas usuwania transakcji: {pMsg}");
                return;
            }

            await LoadTransactions();
        } catch (Exception pEx) {
            Console.WriteLine($"Błąd podczas usuwania transakcji: {pEx.Message}");
            await JSRuntime.InvokeVoidAsync("alert", "Wystąpił błąd podczas usuwania transakcji.");
        }

    }

    //buduje komunikat błędu na podstawie odpowiedzi z serwera
    //xResp - odpowiedź z serwera
    private static string BuildErrorMessage<T>(ApiResponse<T> xResp)
        => xResp.Message ?? ((xResp.Errors != null && xResp.Errors.Count > 0) ? string.Join(", ", xResp.Errors) : "Wystąpił błąd.");

    //buduje komunikat błędu na podstawie odpowiedzi z serwera (przeciążenie)
    //xResp - odpowiedź z serwera
    private static string BuildErrorMessage(ApiResponse xResp)
        => BuildErrorMessage<object>(xResp);

}
