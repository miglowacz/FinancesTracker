@page "/transactions"
@using FinancesTracker.Client.Services
@using FinancesTracker.Shared.DTOs
@using FinancesTracker.Shared.Constants
@using Microsoft.AspNetCore.Components.Web
@using MudBlazor
@* @rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false)) *@
@inject cTransactionService TransactionService
@inject cCategoryService CategoryService
@inject IJSRuntime JSRuntime

<PageTitle>Transakcje</PageTitle>

<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h2>Transakcje finansowe</h2>
                <button class="btn btn-primary">
                    <i class="fas fa-plus"></i> Dodaj transakcję
                </button>
            </div>

            <!-- Filtry -->
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="card-title mb-0">Filtry</h5>
                </div>
                <div class="card-body">
                    <div class="row g-3">
                        <div class="col-md-3">
                            <label class="form-label">Rok</label>
                            <select class="form-select" @bind="mFilter.Year" >
                                <option value="">Wszystkie</option>
                                @for (int pYear = DateTime.Now.Year; pYear >= DateTime.Now.Year - 5; pYear--) {
                                    <option value="@pYear">@pYear</option>
                                }
                            </select>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Miesiąc</label>
                            <select class="form-select" @bind="mFilter.Month">
                                <option value="">Wszystkie</option>
                                @foreach (var pMonth in AppConstants.Months.Polish) {
                                    <option value="@pMonth.Key">@pMonth.Value</option>
                                }
                            </select>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Kategoria</label>
                            <select class="form-select" @bind="mFilter.CategoryId">
                                <option value="">Wszystkie</option>
                                @if (mCategories != null) {
                                    @foreach (var pCategory in mCategories) {
                                        <option value="@pCategory.Id">@pCategory.Name</option>
                                    }
                                }
                            </select>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Podkategoria</label>
                            <select class="form-select" @bind="mFilter.SubcategoryId">
                                <option value="">Wszystkie</option>
                                @if (mSubcategories != null) {
                                    @foreach (var pSubcategory in mSubcategories) {
                                        <option value="@pSubcategory.Id">@pSubcategory.Name</option>
                                    }
                                }
                            </select>
                        </div>
                    </div>
                    <div class="row g-3 mt-2">
                        <div class="col-md-6">
                            <label class="form-label">Szukaj</label>
                            <input type="text" class="form-control" @bind="mFilter.SearchTerm"  placeholder="Szukaj w opisie...">
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Kwota od</label>
                            <input type="number" class="form-control" @bind="mFilter.MinAmount" step="0.01">
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Kwota do</label>
                            <input type="number" class="form-control" @bind="mFilter.MaxAmount" step="0.01">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Lista transakcji -->
            @if (mIsLoading) {
                <div class="text-center p-4">
                    <MudProgressCircular Indeterminate="true" Color="Color.Primary" Size="Size.Large" />
                </div>
            } else if (mTransactions?.Items?.Any() == true) {
                <MudPaper Class="pa-4">
                    <MudTable Items="mTransactions.Items" Hover="true" Dense="true" Bordered="true" Striped="true">
                        <HeaderContent>
                            <MudTh>Data</MudTh>
                            <MudTh>Opis</MudTh>
                            <MudTh>Kwota</MudTh>
                            <MudTh>Kategoria</MudTh>
                            <MudTh>Podkategoria</MudTh>
                            <MudTh>Bank</MudTh>
                            <MudTh>Akcje</MudTh>
                        </HeaderContent>
                        <RowTemplate>
                            @if (context.Id == mEditTransactionId)
                            {
                                <MudTd DataLabel="Data">@context.Date.ToString("dd.MM.yyyy")</MudTd>
                                <MudTd DataLabel="Opis">@context.Description</MudTd>
                                <MudTd DataLabel="Kwota">
                                    <span class="@(context.Amount >= 0 ? "text-success" : "text-danger")">
                                        @context.Amount.ToString("C", System.Globalization.CultureInfo.GetCultureInfo("pl-PL"))
                                    </span>
                                </MudTd>
                                <MudTd DataLabel="Kategoria">
                                    <select class="form-select" @onchange="OnEditCategoryChanged">
                                        <option value="">Wybierz...</option>
                                        @if (mCategories != null) {
                                            @foreach (var pCategory in mCategories) {
                                                <option value="@pCategory.Id">@pCategory.Name</option>
                                            }
                                        }
                                    </select>
                                </MudTd>
                                <MudTd DataLabel="Podkategoria">
                                    <select class="form-select" @bind="mEditTransaction.SubcategoryId">
                                        <option value="">Wybierz...</option>
                                        @foreach (var sub in mEditSubcategories)
                                        {
                                            <option value="@sub.Id">@sub.Name</option>
                                        }
                                    </select>
                                </MudTd>
                                <MudTd DataLabel="Bank">@context.BankName</MudTd>
                                <MudTd DataLabel="Akcje">
                                    <MudButton Variant="Variant.Outlined" Color="Color.Success" Size="Size.Small" OnClick="SaveEdit">
                                        <MudIcon Icon="@Icons.Material.Filled.Save" />
                                    </MudButton>
                                    <MudButton Variant="Variant.Outlined" Color="Color.Default" Size="Size.Small" OnClick="CancelEdit">
                                        <MudIcon Icon="@Icons.Material.Filled.Cancel" />
                                    </MudButton>
                                </MudTd>
                            }
                            else
                            {
                                <MudTd DataLabel="Data">@context.Date.ToString("dd.MM.yyyy")</MudTd>
                                <MudTd DataLabel="Opis">@context.Description</MudTd>
                                <MudTd DataLabel="Kwota">
                                    <span class="@(context.Amount >= 0 ? "text-success" : "text-danger")">
                                        @context.Amount.ToString("C", System.Globalization.CultureInfo.GetCultureInfo("pl-PL"))
                                    </span>
                                </MudTd>
                                <MudTd DataLabel="Kategoria">@context.CategoryName</MudTd>
                                <MudTd DataLabel="Podkategoria">@context.SubcategoryName</MudTd>
                                <MudTd DataLabel="Bank">@context.BankName</MudTd>
                                <MudTd DataLabel="Akcje">
                                    <MudButton Variant="Variant.Outlined" Color="Color.Primary" Size="Size.Small" OnClick="() => StartEdit(context)">
                                        <MudIcon Icon="@Icons.Material.Filled.Edit" />
                                    </MudButton>
                                    <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" OnClick="() => DeleteTransaction(context.Id)">
                                        <MudIcon Icon="@Icons.Material.Filled.Delete" />
                                    </MudButton>
                                </MudTd>
                            }
                        </RowTemplate>
                    </MudTable>
                </MudPaper>
            } else {
                <MudPaper Class="pa-4 text-center">
                    <MudIcon Icon="@Icons.Material.Filled.Inbox" Size="Size.Large" Color="Color.Default" Class="mb-3" />
                    <h5 class="text-muted">Brak transakcji</h5>
                    <p class="text-muted">Nie znaleziono transakcji spełniających kryteria wyszukiwania.</p>
                </MudPaper>
            }
        </div>
    </div>
</div>

@code {
    //przechowuje listę transakcji
    private PagedResult<TransactionDto> mTransactions = new();

    //przechowuje listę kategorii
    private List<cCategory_DTO> mCategories = new();

    //przechowuje listę podkategorii
    private List<cSubcategory_DTO> mSubcategories = new();

    //przechowuje aktualne filtry
    private TransactionFilterDto mFilter = new();

    //przechowuje informację o ładowaniu danych
    private bool mIsLoading = true;

    //przechowuje identyfikator edytowanej transakcji
    private int? mEditTransactionId = null;

    //przechowuje edytowaną transakcję
    private TransactionDto mEditTransaction = new();

    //przechowuje listę podkategorii dla edytowanej transakcji
    private List<cSubcategory_DTO> mEditSubcategories = new();

    //metoda wywoływana podczas inicjalizacji komponentu
    protected override async Task OnInitializedAsync() {
        //ładuje kategorie przy starcie komponentu
        await LoadCategories();

        //ładuje transakcje przy starcie komponentu
        await LoadTransactions();
    }

    //ładuje kategorie z serwisu
    //brak parametrów
    private async Task LoadCategories() {
        //pobiera kategorie z serwisu
        var pResp = await CategoryService.GetCategoriesAsync();
        if (pResp.Success) {
            mCategories = pResp.Data ?? new List<cCategory_DTO>();
        } else {
            mCategories = new List<cCategory_DTO>();
            Console.WriteLine($"błąd podczas ładowania kategorii: {BuildErrorMessage(pResp)}");
        }
    }

    //ładuje transakcje z serwisu na podstawie filtrów
    //brak parametrów
    private async Task LoadTransactions() {
        mIsLoading = true;

        Console.WriteLine("TEST");

        try {
            var pResp = await TransactionService.GetTransactionsAsync(mFilter);
            if (!pResp.Success) {
                Console.WriteLine($"błąd podczas ładowania transakcji: {BuildErrorMessage(pResp)}");
                mTransactions = new PagedResult<TransactionDto>();
            } else {
                mTransactions = pResp.Data ?? new PagedResult<TransactionDto>();
            }
        } catch (Exception pEx) {
            Console.WriteLine($"błąd podczas ładowania transakcji: {pEx.Message}");
            mTransactions = new PagedResult<TransactionDto>();
        } finally {
            mIsLoading = false;
        }

    }

    //usuwa transakcję o podanym identyfikatorze
    //xTransactionId - identyfikator transakcji do usunięcia
    private async Task DeleteTransaction(int xTransactionId) {
        //potwierdzenie usunięcia
        bool pConfirmDelete = await JSRuntime.InvokeAsync<bool>("confirm", "Czy na pewno chcesz usunąć tę transakcję?");
        if (!pConfirmDelete)
            return;

        try {
            var pResp = await TransactionService.DeleteTransactionAsync(xTransactionId);

            //jawne rzutowanie, aby odczytać właściwość Success (uniknięcie kolizji ze statyczną metodą Success)
            if (!((ApiResponse<object>)pResp).Success) {
                var pMsg = pResp.Message ?? (pResp.Errors is { Count: > 0 }
                    ? string.Join(", ", pResp.Errors)
                    : "Nie udało się usunąć transakcji.");

                Console.WriteLine($"Błąd podczas usuwania transakcji: {pMsg}");
                await JSRuntime.InvokeVoidAsync("alert", $"Wystąpił błąd podczas usuwania transakcji: {pMsg}");
                return;
            }

            await LoadTransactions();
        } catch (Exception pEx) {
            Console.WriteLine($"Błąd podczas usuwania transakcji: {pEx.Message}");
            await JSRuntime.InvokeVoidAsync("alert", "Wystąpił błąd podczas usuwania transakcji.");
        }

    }

    //rozpoczyna edycję transakcji
    //transaction - transakcja do edytowania
    private void StartEdit(TransactionDto transaction)
    {
        mEditTransactionId = transaction.Id;
        mEditTransaction = new TransactionDto
        {
            Id = transaction.Id,
            Date = transaction.Date,
            Description = transaction.Description,
            Amount = transaction.Amount,
            CategoryId = transaction.CategoryId,
            SubcategoryId = transaction.SubcategoryId,
            BankName = transaction.BankName
        };
        UpdateEditSubcategories();
    }

    //anuluje edycję transakcji
    private void CancelEdit()
    {
        mEditTransactionId = null;
        mEditTransaction = new();
        mEditSubcategories = new();
    }

    //zapisuje zmiany edytowanej transakcji
    private async Task SaveEdit()
    {
        // Call your update service here, e.g.:
        var resp = await TransactionService.UpdateTransactionAsync(mEditTransaction.Id, mEditTransaction);
        if (resp.Success)
        {
            await LoadTransactions();
            CancelEdit();
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Błąd: {BuildErrorMessage(resp)}");
        }
    }

    //metoda wywoływana po zmianie kategorii w edytowanej transakcji
    //e - argument zdarzenia zmiany
    private void OnEditCategoryChanged(ChangeEventArgs e) {
        //parsuje wartość wybranej kategorii
        mEditTransaction.CategoryId = int.TryParse(e.Value?.ToString(), out var val) ? val : null;
        
        //czyści wybór podkategorii
        mEditTransaction.SubcategoryId = null;
        
        //aktualizuje dostępne podkategorie
        UpdateEditSubcategories();
        
        //Blazor automatycznie wywoła re-render po zakończeniu handlera
    }

    //aktualizuje listę podkategorii dla edytowanej transakcji
    private void UpdateEditSubcategories()
    {
        mEditSubcategories = mCategories
            .FirstOrDefault(c => c.Id == mEditTransaction.CategoryId)?.Subcategories
            ?? new List<cSubcategory_DTO>();
    }

    //buduje komunikat błędu na podstawie odpowiedzi z serwera
    //xResp - odpowiedź z serwera
    private static string BuildErrorMessage<T>(ApiResponse<T> xResp)
        => xResp.Message ?? ((xResp.Errors != null && xResp.Errors.Count > 0) ? string.Join(", ", xResp.Errors) : "Wystąpił błąd.");

    //buduje komunikat błędu na podstawie odpowiedzi z serwera (przeciążenie)
    //xResp - odpowiedź z serwera
    private static string BuildErrorMessage(ApiResponse xResp)
        => BuildErrorMessage<object>(xResp);

}
